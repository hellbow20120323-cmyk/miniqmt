# 159201 网格策略 — 完整开发文档

本文档梳理当前「Mac 信号 → Windows 下单」整条链路的逻辑、文件约定、安全机制与恢复策略，供开发与运维参考。

---

## 一、项目概述与架构

### 1.1 目标

- **Mac 端**：运行 `mac_dashboard.py`，读取共享目录中的行情与真实持仓，按与回测一致的 ATR 动态网格 + 趋势自适应逻辑，在满足条件时写入买卖信号到 `order_signal.json`。
- **Windows 端**：
  - `bridge_producer.py`：从 QMT 拉取 159201 行情与持仓，写入 `shared_quote.json`，供 Mac 使用。
  - `order_executor.py`：轮询 `order_signal.json`，校验、资金预检后调用 QMT 下单，并消费信号（移动文件 + 记录已执行），避免重复执行。
- **共享方式**：Mac 与 Windows 通过同步盘（如 iCloud）共享同一目录，约定为 Windows 路径 `C:\Mac\Home\Documents\miniqmt`，Mac 端为脚本所在目录（同步后一致）。

### 1.2 数据流概览

```
Mac_dashboard                   共享目录/文件                    Windows
     |                               |                              |
     | 读 shared_quote.json          |  order_signal.json            | 写 shared_quote.json (bridge_producer)
     | (行情 + 真实持仓)               |  order_result.json            | 读 order_signal.json → 下单 → 消费 (order_executor)
     |                               |  executed_signals.json        |
     | 写 order_signal.json (含       |  order_signal_done/*.done      |
     |  signal_id)                   |                              |
     | 静默期：等持仓更新或超时          |                              |
```

### 1.3 涉及文件一览

| 文件 | 位置 | 说明 |
|------|------|------|
| `mac_dashboard.py` | Mac（与共享目录同步） | 实盘看板：读行情、算 ATR/趋势、发买卖信号、静默期 |
| `mac_backtest_159201.py` | Mac | 回测：与 dashboard 同套策略参数与逻辑，用于验证与调参 |
| `bridge_producer.py` | Windows | 桥接：写 shared_quote.json（行情+持仓） |
| `order_executor.py` | Windows | 执行器：读信号、幂等、校验、资金预检、下单、消费 |
| `shared_quote.json` | 共享目录 | 行情 + 持仓，由 bridge_producer 写入，Mac 读取 |
| `order_signal.json` | 共享目录 | 单条信号，Mac 写入，order_executor 读后消费（移走） |
| `order_result.json` | 共享目录 | 最近一次执行结果，order_executor 写入 |
| `executed_signals.json` | 共享目录 | 已执行 signal_id 列表，order_executor 持久化 |
| `order_signal_done/*.done` | 共享目录 | 已消费信号备份，按 signal_id 命名 |
| `dashboard_state.json` | Mac/共享目录 | Mac 本地状态：last_buy_price、positions、hold_layers 等 |
| `order_executor.log` | Windows 共享目录 | 执行器日志 |

---

## 二、共享目录与配置约定

- **SHARED_DIR**（Windows）：`C:\Mac\Home\Documents\miniqmt`
- **标的**：`159201.SZ`（Mac、bridge_producer、order_executor 一致）
- **QMT**：`QMT_USERDATA_PATH`、`ACCOUNT_ID`、`ACCOUNT_TYPE` 在 bridge_producer 与 order_executor 中一致（当前为同一账号）

---

## 三、Mac 端：mac_dashboard.py

### 3.1 路径与状态文件

- 脚本目录 `_SCRIPT_DIR` 即工作目录（与同步盘对齐后即 SHARED_DIR）。
- `SHARED_FILE` = `shared_quote.json`，`SIGNAL_FILE` = `order_signal.json`，`STATE_FILE` = `dashboard_state.json`。
- 状态先写临时文件再 `os.replace` 落盘，保证崩溃不产生半成品；信号同样原子写入（`SIGNAL_TMP` → `SIGNAL_FILE`）。

### 3.2 策略参数（与回测对齐）

| 参数 | 值 | 说明 |
|------|-----|------|
| STOCK_CODE | 159201.SZ | 标的 |
| ATR_PERIOD | 14 | ATR 周期 |
| ATR_GRID_FACTOR | 0.38 | 网格弹性系数 |
| GRID_STEP_FLOOR | 0.0012 | 步长下限 0.12% |
| LAYER_STEP_BONUS | 0.0001 | 层数加成步长（每层 +0.01%） |
| SELL_PROFIT_THRESHOLD | 0.005 | 止盈阈值 0.5% |
| SELL_THRESHOLD_FACTOR | 1.4 | 涨多系数，实际止盈 = 阈值 × 1.4 |
| BUY_STEP_FACTOR | 1.0 | 买入步长系数 |
| TREND_MA_PERIOD | 60 | 趋势 MA60 |
| MAX_LAYERS | 9 | 最大层数 |
| BATCH_MONEY | 200000 | 流动仓 20 万，均权 9 层 |
| COOLING_BARS / COOLING_BARS_SHORT | 15 / 5 | 全平后冷静期（分钟），RSI<35 用 5 分钟 |
| RSI_COOLING_THRESHOLD | 35 | 动态冷静期 RSI 阈值 |
| ATR_CIRCUIT_BREAKER_* | 开启，2.0，60 | ATR 熔断：当前 ATR > 近期均值×2 则暂停加仓 |
| DATA_STALE_SECONDS | 300 | 行情超过 5 分钟未更新则不发新信号 |

趋势自适应（与回测一致）：上升趋势放宽网格、提高止盈、减小仓位；下降趋势收紧网格、降低止盈、加大仓位。MA60 斜率经 3 周期 EMA 平滑。

### 3.3 主循环逻辑概要

1. **读行情**：读 `shared_quote.json`，取 `history`、`price`、`position`。
2. **数据新鲜度**：若文件修改时间超过 `DATA_STALE_SECONDS`，本周期不发出新信号（避免断网/断桥误触发）。
3. **与真实持仓同步**：若桥显示 `position.volume == 0` 而本地 state 有持仓，则以真实为准清空本地持仓并落盘，避免重复卖。
4. **静默期解除**（见下节）：根据真实持仓层数/体积与超时，清除买入/卖出 pending。
5. **卖出**：有持仓时，按「单笔止盈」：若 `curr_p >= lot["buy_price"] * (1 + sell_eff)` 则将该笔加入待删，汇总后若存在则先检查**卖出静默期**；未在静默期则更新 positions、落盘、`execute_signal("SELL", ...)`，并设 `pending_sell_since`、`pending_sell_volume`。
6. **买入**：若 `hold_layers < MAX_LAYERS` 且价格跌破 `last_buy_price * (1 - grid_step * BUY_STEP_FACTOR)`，且非冷静期、非 ATR 熔断、行情新鲜，则检查**买入静默期**；未在静默期则计算 shares（均权）、更新 state、落盘、`execute_signal("BUY", ...)`，并设 `pending_until_layers`、`pending_since`。
7. **冷静期**：全平后（hold_layers==0）在 `last_sell_timestamp` 起算的冷静期内（RSI<35 用 5 分钟，否则 15 分钟）不新开第一层。

### 3.4 静默期（防同层重复发单）

- **买入静默期**：发出买入信号后设 `pending_until_layers = 当前层数`，`pending_since = 当前时间`。在解除前，若「真实持仓换算层数」仍 < `pending_until_layers` 且未超时（`PENDING_TIMEOUT_SEC = 120`），则本周期不再触发买入。解除条件：`real_layers >= pending_until_layers` 或超时。
- **卖出静默期**：发出卖出信号后设 `pending_sell_since`、`pending_sell_volume = 发出时持仓量`。在解除前，若 `real_volume >= pending_sell_volume` 且未超时，则本周期不再触发卖出。解除条件：`real_volume < pending_sell_volume` 或超时。
- 真实层数：`real_layers = int(real_volume * curr_p / PART_MONEY)`（与均权每层金额一致）。静默期仅内存，进程重启后自然解除。

### 3.5 信号输出

- `execute_signal(direction, price, reason, shares)`：先更新 state 中的 signals 列表与 UI，再原子写入 `order_signal.json`，字段包括：`signal_id`（uuid4.hex）、`code`、`direction`、`price`、`shares`、`timestamp`、`reason`。
- 顺序约定：先 `_save_state` 再写信号，避免崩溃后状态已更新但信号未写导致不一致。

### 3.6 恢复与容错

- 启动时从 `dashboard_state.json` 加载 last_buy_price、positions、hold_layers 等；若与 `shared_quote.json` 中真实持仓不一致（例如桥显示 0 持仓），以真实持仓为准覆盖本地状态。
- 行情过期不发单；静默期超时自动解除，避免死锁。

---

## 四、Windows 端：order_executor.py

### 4.1 配置

- `SHARED_DIR`、`ORDER_SIGNAL_PATH`、`EXECUTED_SIGNALS_FILE`、`DONE_DIR`、`ORDER_RESULT_PATH`、`QMT_USERDATA_PATH`、`ACCOUNT_ID`、`ACCOUNT_TYPE`、`ALLOWED_CODES`（仅 159201.SZ）、`MAX_SHARES_PER_ORDER`（10 万）、`CASH_BUFFER_RATIO`（1.01）、`POLL_INTERVAL_SEC`（3）、`SIGNAL_EXPIRE_SEC`（300）、`MAX_EXECUTED_IDS`（5000）。

### 4.2 单次轮询流程（run_once）

1. **读文件**：若不存在 `order_signal.json` 则 return；否则读取 JSON。
2. **signal_id**：若无 signal_id，消费文件（移入 done）、写 order_result 失败、return。
3. **幂等**：从 `executed_signals.json` 加载已执行 id 列表；若当前 signal_id 已在列表中，仅消费文件并 return。
4. **校验**：`validate_signal` 检查必填字段、direction、shares 为 100 的整数倍、code 在白名单、price>0、未过期、单笔股数上限；不通过则消费、写 order_result、save_executed_id、return。
5. **资金预检**：`trader.query_stock_asset(acc)` 取可用资金；买入时要求 `asset.cash >= price * shares * CASH_BUFFER_RATIO`，不满足则消费、写 order_result、save_executed_id、return。
6. **下单**：`trader.order_stock(..., xtconstant.FIX_PRICE, price, ...)` 限价单。
7. **事后**：save_executed_id、consume_signal_file（移动到 `order_signal_done/order_signal_{signal_id}.done`）、写 order_result（success/failed）。

顺序严格：幂等 → 校验 → 资金预检 → 下单 → 消费，确保「决定不执行」时也会消费，避免重复重试。

### 4.3 消费与已执行记录

- 消费：将 `order_signal.json` 重命名为 `order_signal_done/order_signal_{signal_id}.done`，确保同一文件不会被再次读取。
- 已执行 id 写入 `executed_signals.json`，保留最近 `MAX_EXECUTED_IDS` 条，重启后仍能防重。

### 4.4 日志与 order_result

- 日志写入 `order_executor.log` 及 stdout，记录读取/跳过/执行/拒绝及原因。
- `order_result.json` 覆盖写入最近一次结果：signal_id、status、order_id、message、timestamp。

---

## 五、Windows 端：bridge_producer.py

- 订阅 159201.SZ 1 分钟行情，循环：拉 tick、拉 60 根 1 分钟 close 作为 history、`query_stock_positions` 取当前标的持仓，写入 `shared_quote.json`（code、price、history、position、time）。
- 与 dashboard、executor 共用 `SHARED_DIR`、同一标的；执行器下单后，下一轮 query_stock_positions 会拿到新持仓，无需执行器回写持仓。

---

## 六、回测：mac_backtest_159201.py（与实盘对齐部分）

- 参数与 dashboard 对齐：ATR_GRID_FACTOR、GRID_STEP_FLOOR、LAYER_STEP_BONUS、SELL_PROFIT_THRESHOLD、SELL_THRESHOLD_FACTOR、BUY_STEP_FACTOR、趋势系数、MAX_LAYERS、BATCH_MONEY、冷静期、ATR 熔断等。
- 回测为「单笔止盈」：SELL_BY_LOT=True，每笔达到止盈阈值即卖出该笔，与 dashboard 一致。
- 可选功能（实盘未启用或独立）：层数自适应止盈折扣、多周期共振、时间过滤、滑点压力测试、单周期浮亏止损等，见脚本内开关。
- 固定仓 30 万 / 流动仓 20 万：BETA_CAPITAL=300000，BATCH_MONEY=200000，用于 Beta 与资金占用年化等统计。

---

## 七、安全机制汇总

| 机制 | 位置 | 说明 |
|------|------|------|
| 信号幂等 | Windows 执行器 | signal_id 持久化，已执行则只消费不下单 |
| 先校验再下单 | Windows 执行器 | 必填、格式、白名单、限幅、过期；不通过则消费并记录 |
| 可用资金预检 | Windows 执行器 | 买入前 available_cash >= price*shares*1.01，否则消费不执行 |
| 静默期 | Mac | 发单后锁定层/笔，等持仓更新或 120 秒超时，避免同层重复发单 |
| 先消费再返回 | Windows 执行器 | 执行或跳过均先移动/删除信号文件，再写结果/日志 |
| 标的白名单 | Windows 执行器 | 仅 ALLOWED_CODES 内标的可下单 |
| 单笔限幅 | Windows 执行器 | 单笔股数 ≤ MAX_SHARES_PER_ORDER |
| 行情过期不发单 | Mac | shared_quote 超过 DATA_STALE_SECONDS 不触发新信号 |
| 状态先于信号落盘 | Mac | 先 _save_state 再 _write_signal_atomic，崩溃恢复不重复发单 |
| 以真实持仓为准 | Mac | 桥显示 0 持仓时清空本地持仓，避免重复卖 |

---

## 八、部署与运行

- **Mac**：在脚本目录（与同步盘对齐）执行 `python3 mac_dashboard.py`（或激活 venv 后执行）。依赖：pandas、numpy、rich。
- **Windows**：先启动 `bridge_producer.py`，再启动 `order_executor.py`；两者共用同一 SHARED_DIR 与 QMT 账号；执行器依赖 xtquant、QMT 已登录。
- **网络/进程中断**：Mac 重启后从 dashboard_state.json 恢复；若 shared_quote 未更新则不发新信号；静默期不落盘，重启后自动解除。Windows 执行器重启后依赖 executed_signals.json 防重，未消费的信号会被再次读取并最多执行一次（幂等会拦截已执行过的 signal_id）。

---

## 九、文档与版本

- 策略细节与参数可参考 `策略文档_159201.md`、`STRATEGY_159201.md`。
- 实盘恢复与容错见 `实盘恢复与容错说明.md`。
- 本开发文档与代码同步更新，如有逻辑变更请同步修改此文档。
