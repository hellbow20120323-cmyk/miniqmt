# 离线测试流程（Mac 信号 → Windows 执行器）

在**不连接 QMT、不实盘下单**的前提下，验证信号格式、校验与限幅、消费协议、部分成交对齐与恢复逻辑。

---

## 一、测试环境约定

### 1.1 独立测试目录

使用与实盘隔离的目录，避免污染真实 shared 与 state：

- **Mac 测试根目录**：`miniqmt/test_offline/`（或任意 `test_offline` 子目录）
- 测试时将该目录作为「共享目录」：其中放置 `shared_quote.json`、`order_signal.json`、`order_result.json`、`dashboard_state.json`、`executed_signals.json` 等

### 1.2 测试方式概览

| 类型 | 说明 |
|------|------|
| **回测** | 已存在：`mac_backtest_159201.py`，不依赖共享目录，纯 CSV + 逻辑验证 |
| **Mac 逻辑单步** | 用脚本向测试目录写 mock `shared_quote.json` / `dashboard_state.json`，调用 dashboard 的核心里程或读结果，检查是否写出合规的 `order_signal.json` |
| **执行器 dry-run** | 不连 QMT，仅：读 `order_signal.json` → 校验 → 写 `order_result.json`（及 filled_shares）→ 消费（移文件） |
| **部分成交** | 手写或脚本写 `order_result.json`（filled_shares < requested_shares），用 Mac 侧逻辑或单步脚本应用 `_apply_order_result`，检查 state/positions/pending_buy 是否正确 |
| **恢复与幂等** | 重放同一 signal_id、或先写 executed_signals 再放信号，验证只消费不执行、状态不重复 |

---

## 二、阶段 1：回测自检（无需改代码）

**目的**：确认策略参数与买卖逻辑与实盘脚本一致，无语法/导入错误。

1. 准备数据：`history_159201_1m.csv` 放在 `miniqmt/` 下（或脚本内 `FILE_PATH` 所指路径）。
2. 执行：
   ```bash
   cd /path/to/miniqmt
   python3 mac_backtest_159201.py
   ```
3. 检查：无报错、输出中有成交笔数/Alpha/Beta/回撤等；可选与历史结果对比。

---

## 三、阶段 2：Mac 端「发信号」离线验证

**目的**：在固定行情与状态下，确认 dashboard 会写出符合约定的 `order_signal.json`（含 signal_id、code、direction、price、shares、timestamp、reason）。

### 3.1 准备测试目录

```bash
mkdir -p /path/to/miniqmt/test_offline
cd /path/to/miniqmt/test_offline
```

### 3.2 构造 mock shared_quote.json

最少需：`price`、`history`（约 65+ 个 close）、`position`（含 `volume`）、`time`。示例（1 分钟 close 列表，可复制多段凑够长度）：

```json
{
  "code": "159201.SZ",
  "price": 1.052,
  "history": [1.05, 1.051, 1.049, 1.052, ...],
  "position": { "volume": 0, "can_use_volume": 0 },
  "time": "10:30:00"
}
```

- 要测「触发买入」：保证 `history` 足够长、价格低于你准备的 `dashboard_state.json` 里的 `last_buy_price` 且满足网格步长。
- 要测「不触发」：例如 `position.volume` 已很大、或 `price` 高于 last_buy_price，避免误触发。

### 3.3 构造 dashboard_state.json（可选）

若测「从空仓发第一笔买」：可只保留 `last_buy_price`、`hold_layers: 0`、`positions: []` 等，其余用默认。  
若测「从有仓发卖」：在 `positions` 里写一两笔，`buy_price` 设低一些，使 mock 的 `price` ≥ `buy_price * (1 + sell_eff)`。

### 3.4 用测试目录跑 dashboard（需改路径或环境）

**方式 A（改脚本临时指向测试目录）**：在 `mac_dashboard.py` 中临时将 `_SCRIPT_DIR` 改为测试目录，然后：

```bash
python3 mac_dashboard.py
```

运行几秒后 Ctrl+C，检查 `test_offline/order_signal.json` 是否存在且含 `signal_id`、`direction`、`shares`、`price`、`timestamp`、`reason`。

**方式 B（推荐：独立小脚本）**：在 `test_offline/` 下写 `test_mac_signal.py`：  
- 设置 `sys.path` 或复制必要常量，将「共享目录」指向当前目录；  
- 读入 mock 的 `shared_quote.json` 和（可选）`dashboard_state.json`；  
- 调用 dashboard 中的 `history_to_df`、`calculate_atr_and_trend`，再根据与 main 相同的条件判断是否触发买卖，若触发则调用 `execute_signal`（此时会写当前目录下的 `order_signal.json`）；  
- 断言 `order_signal.json` 存在且字段齐全。

### 3.5 检查清单

- [ ] `order_signal.json` 存在且为合法 JSON  
- [ ] 含字段：`signal_id`、`code`（159201.SZ）、`direction`（BUY/SELL）、`price`、`shares`（100 的整数倍）、`timestamp`、`reason`  
- [ ] 若为 BUY：`dashboard_state.json` 中已先更新 `last_buy_price`、`positions`、`hold_layers` 再写出信号（先状态后信号）

---

## 四、阶段 3：执行器 dry-run（不连 QMT）

**目的**：验证「读信号 → 校验 → 写 order_result → 消费」流程，不真实下单。

### 4.1 方案 A：本机用测试目录模拟执行器

在 Mac 或任意本机建测试目录，例如 `miniqmt/test_offline_exec/`，其中放入：

- `order_signal.json`（由上一步或手写，含合法 signal_id、code、direction、shares、price、timestamp）

写一个**独立脚本** `test_executor_dryrun.py`（与 `order_executor.py` 同层或放在 test_offline 下）：

- 将 `SHARED_DIR` 指向 `test_offline_exec/`（或通过环境变量/参数传入）。
- **不**创建 `XtQuantTrader`、不调用 `order_stock`。
- 依次：读 `order_signal.json` → `load_executed_ids`（读测试目录下 `executed_signals.json`）→ 幂等判断 → `validate_signal` → 若通过则写 `order_result.json`（含 `requested_shares`、`filled_shares=requested_shares`、`direction`），然后 `consume_signal_file`（移到 `order_signal_done/` 或删除）。
- 若校验失败：仍写 `order_result.json`（status=failed）、消费信号文件。

这样可验证：合法信号被消费且写出 result；非法信号（缺字段、错误 code、超限）被拒绝并消费。

### 4.2 方案 B：Windows 上真实执行器但用「测试共享目录」

在 Windows 上把 `order_executor.py` 的 `SHARED_DIR` 临时改为测试目录（如 `D:\miniqmt_test`），并**注释掉** `trader.order_stock`，改为直接写 `write_order_result(..., 'success', order_id=1, ...)` 再 `consume_signal_file`。运行后检查测试目录内：

- `order_signal.json` 已消失（被消费）
- `order_signal_done/order_signal_{signal_id}.done` 存在
- `order_result.json` 含 `status`、`requested_shares`、`filled_shares`
- `executed_signals.json` 中已记录该 signal_id

### 4.3 检查清单

- [ ] 合法信号：校验通过 → 写 order_result → 消费 → executed 有记录  
- [ ] 非法信号（如 code 不在白名单、shares 非 100 倍数）：写 order_result failed → 消费 → 不重复执行  
- [ ] 同一 signal_id 再放一份：幂等 → 只消费不写新 result（或 result 与首次一致）

---

## 五、阶段 4：部分成交（Mac 侧状态对齐）

**目的**：不依赖真实下单，验证 `_apply_order_result` 与补单/卖回写逻辑。

### 5.1 买单部分成交

1. 在测试目录准备 `dashboard_state.json`：`positions` 有一笔（如 2200 股），`last_sent_signal_id`、`last_sent_signal_direction`: "BUY"、`last_sent_signal_shares`: 2200、`last_sent_signal_price`: 1.05、`last_sent_buy_prev_anchor`: 1.06、`last_sent_was_topup`: false。
2. 写 `order_result.json`：同一 `signal_id`，`requested_shares`: 2200，`filled_shares`: 1100，`direction`: "BUY"。
3. 用单步脚本或临时改 dashboard 的 `_SCRIPT_DIR` 指向测试目录，执行一次主循环中「读 order_result → _apply_order_result」的逻辑（或直接调用 `_apply_order_result(读到的 result)`）。
4. 检查：  
   - `positions` 最后一笔为 1100 股；  
   - `pending_buy_shares`: 1100，`pending_buy_price`、`pending_buy_since` 已设；  
   - `last_applied_result_signal_id` 为该 signal_id。

### 5.2 卖单部分成交

1. 在测试目录准备 state：`last_sent_signal_id`、`last_sent_signal_direction`: "SELL"、`last_sent_sell_removed_lots`: [{ "shares": 2200, "cost": 2310, "buy_price": 1.05 }]，`positions` 已不含该笔（已“卖出”）。
2. 写 `order_result.json`：同一 `signal_id`，`requested_shares`: 2200，`filled_shares`: 1100，`direction`: "SELL"。
3. 执行一次 `_apply_order_result`。
4. 检查：  
   - `positions` 中有一笔 1100 股（未卖部分写回）；  
   - `hold_t0_volume`、`total_cost`、`hold_layers` 已重算；  
   - 卖出静默期相关状态已清（若你把它存在 state 里）。

### 5.3 补单超时

1. 在 state 中设 `pending_buy_shares`: 1100，`pending_buy_since`: 超过 15 分钟前的时间戳。
2. 跑一轮主循环（或只跑「补单超时」分支）。
3. 检查：`pending_buy_shares`、`pending_buy_price`、`pending_buy_since` 已被清空。

---

## 六、阶段 5：恢复与幂等

### 6.1 状态先于信号

1. 用脚本模拟「先写 order_signal.json，后写 dashboard_state.json」的旧逻辑（或回滚代码临时还原），触发一次买。
2. 模拟崩溃（不写 state），再重启 dashboard（或单步脚本）。
3. 验证：若 state 未更新，同一条件会再次触发并写出**新**信号（说明先状态后信号的重要性；恢复后应改为先写 state 再写信号，再测一次「只发一次」）。

### 6.2 执行器幂等

1. 在测试目录的 `executed_signals.json` 中预先写入某 `signal_id`。
2. 放入一份 `order_signal.json`，其中 `signal_id` 与上述相同。
3. 运行 dry-run 执行器（或真实执行器 mock 版）。
4. 检查：不应再写 order_result 的 success、不应调用下单；应只消费信号文件并（可选）打日志「已执行过」。

### 6.3 真实持仓同步（Mac）

1. 在 state 中设 `hold_t0_volume` > 0、`positions` 非空。
2. 在 `shared_quote.json` 中设 `position.volume`: 0。
3. 跑一轮主循环。
4. 检查：state 中 `positions` 已清空、`hold_t0_volume` 为 0，并已落盘。

---

## 七、推荐执行顺序与产出

| 顺序 | 阶段 | 产出 |
|------|------|------|
| 1 | 回测自检 | 回测通过、输出合理 |
| 2 | Mac 发信号离线 | 测试目录下出现合规 `order_signal.json` |
| 3 | 执行器 dry-run | 信号被校验、写 result、消费；幂等与非法信号行为符合预期 |
| 4 | 部分成交 | state/positions/pending_buy 与设计一致；补单超时清除 |
| 5 | 恢复与幂等 | 先状态后信号、executor 幂等、真实持仓同步均符合预期 |

---

## 八、已提供的最小可运行脚本（test_offline/）

以下脚本在 `miniqmt/test_offline/` 下，**以当前目录为“共享目录”**，无需改主工程路径。

### 8.1 执行器 dry-run：`test_executor_dryrun.py`

不连 QMT，只做：读 `order_signal.json` → 幂等检查 → 校验 → 写 `order_result.json`（success + requested_shares/filled_shares）→ 记录 `executed_signals.json` → 将信号文件移到 `order_signal_done/`。

```bash
cd /path/to/miniqmt/test_offline
# 先放入一份合法 order_signal.json，例如：
echo '{"signal_id":"abc123","code":"159201.SZ","direction":"BUY","price":1.05,"shares":2200,"timestamp":'$(date +%s)',"reason":"test"}' > order_signal.json
python3 test_executor_dryrun.py
```

检查：`order_signal.json` 已消失；`order_signal_done/order_signal_abc123.done` 存在；`order_result.json` 含 `status: success`、`requested_shares`、`filled_shares`；`executed_signals.json` 含 `abc123`。再放一份同 `signal_id` 的 `order_signal.json` 再跑一次，应只消费不写新 result（幂等）。

### 8.2 部分成交状态对齐：`test_apply_partial_fill.py`

读本目录下 `dashboard_state.json` 与 `order_result.json`，应用与 `_apply_order_result` 一致的逻辑，写回 `dashboard_state.json`。

**示例：买单部分成交（1100/2200）**

```bash
cd /path/to/miniqmt/test_offline
# 1）准备 state：刚发过一笔 BUY 2200，最后一笔为 2200 股
cat > dashboard_state.json << 'EOF'
{
  "last_buy_price": 1.05,
  "hold_layers": 1,
  "positions": [{"shares": 2200, "cost": 2310, "buy_price": 1.05}],
  "hold_t0_volume": 2200,
  "total_cost": 2310,
  "last_sent_signal_id": "sig-buy-001",
  "last_sent_signal_direction": "BUY",
  "last_sent_signal_shares": 2200,
  "last_sent_signal_price": 1.05,
  "last_sent_buy_prev_anchor": 1.06,
  "last_sent_was_topup": false
}
EOF
# 2）准备 order_result：只成交 1100
cat > order_result.json << 'EOF'
{"signal_id": "sig-buy-001", "status": "success", "requested_shares": 2200, "filled_shares": 1100, "direction": "BUY"}
EOF
python3 test_apply_partial_fill.py
```

检查输出：`positions` 最后一项为 1100 股；`pending_buy_shares` 为 1100，`pending_buy_price`、`pending_buy_since` 已设。

**示例：卖单部分成交（1100/2200）**

```bash
# state：刚发过 SELL 2200，已从 positions 删掉该笔，并记录了 last_sent_sell_removed_lots
cat > dashboard_state.json << 'EOF'
{
  "last_buy_price": 1.05,
  "hold_layers": 0,
  "positions": [],
  "hold_t0_volume": 0,
  "total_cost": 0,
  "last_sent_signal_id": "sig-sell-001",
  "last_sent_signal_direction": "SELL",
  "last_sent_signal_shares": 2200,
  "last_sent_sell_removed_lots": [{"shares": 2200, "cost": 2310, "buy_price": 1.05}]
}
EOF
cat > order_result.json << 'EOF'
{"signal_id": "sig-sell-001", "status": "success", "requested_shares": 2200, "filled_shares": 1100, "direction": "SELL"}
EOF
python3 test_apply_partial_fill.py
```

检查：`positions` 有一笔 1100 股（未卖部分写回），`hold_layers`/`hold_t0_volume`/`total_cost` 已更新。

### 8.3 其他

- **mock shared_quote**：手写 `shared_quote.json` 用于阶段 2（Mac 发信号）；若用真实 dashboard 指向测试目录，需临时改 `_SCRIPT_DIR` 或通过包装脚本切 cwd 再 import。
- 以上脚本仅依赖标准库与测试目录，无需 QMT、无需实盘。

---

## 九、注意事项

- 所有离线测试使用**独立测试目录**，不要指向实盘共享目录或实盘 state。  
- 执行器 dry-run 时**不要**调用 `trader.connect()` / `order_stock()`，可用 mock 或条件跳过。  
- 部分成交测试中，`order_result` 的 `signal_id` 必须与 state 中 `last_sent_signal_id` 一致，否则 `_apply_order_result` 会直接 return。  
- 测试通过后，若有临时改路径或注释，需还原再上线。
