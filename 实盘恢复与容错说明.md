# 实盘恢复与容错说明（mac_dashboard.py）

在**网络中断、程序挂死或设备重启**后，策略可自动恢复并避免因状态不一致导致的重复发单或误判。

## 1. 状态先于信号持久化

- **顺序**：每次触发买卖时，先更新内存状态 → **立即写入 `dashboard_state.json`** → 再写 `order_signal.json` 并播报。
- **目的**：若在“发信号”之后、写状态之前进程崩溃，重启后会根据旧状态再次满足条件并**重复发单**。先写状态可保证：一旦崩溃，磁盘上已是“已卖出/已买入”的状态，重启后不会对同一笔逻辑再发一次单。

## 2. 原子写入

- **状态文件**：先写 `dashboard_state.json.tmp`，`flush` + `fsync` 后执行 `os.replace(.tmp, 正式路径)`，避免写一半时断电导致 JSON 损坏。
- **信号文件**：同样先写 `order_signal.json.tmp` 再 `replace`，避免执行端读到半截 JSON。

## 3. 状态加载校验

- 启动时从 `dashboard_state.json` 读取 `positions`，并做**结构校验**：只保留含 `shares/cost/buy_price` 且数值合法的项，非法或旧格式一律丢弃，避免损坏或历史格式导致逻辑错乱。
- 根据校验后的 `positions` 重算 `hold_layers`、`hold_t0_volume`、`total_cost`，保证与列表一致。

## 4. 行情新鲜度（网络/桥中断）

- 使用 `shared_quote.json` 的**文件修改时间**判断是否过期；超过 **5 分钟**（`DATA_STALE_SECONDS=300`）未更新则视为断线或桥中断。
- **过期期间**：不再发出任何新的买卖信号，仅刷新界面；标题栏显示「行情已过期，暂停发单」。
- 恢复推送后，文件 mtime 更新，自动重新允许发单，无需人工干预。

## 5. 与真实持仓同步（防止重复卖）

- 若桥接数据里 **真实持仓 `position.volume == 0`**，而本地状态里 **`hold_t0_volume > 0`**（例如外盘已平仓、或 Windows 端已执行卖单而 Mac 曾崩溃未写状态），则以**真实持仓为准**：将本地 `positions` 清空并落盘，并设 `last_sell_timestamp`。
- 这样不会在“实际已空仓”的情况下再次发出卖出信号，避免重复卖或逻辑混乱。

## 6. 首次锚点与迁移

- `last_buy_price` 仅在 **`curr_p > 0`** 时被初始化，避免用 0 作为锚点。
- 若磁盘上是旧版状态（无 `positions` 但有 `hold_t0_volume/total_cost`），会**自动合成一笔** `positions` 并**立即保存**，便于下次启动直接恢复。

## 7. 建议运维

- **进程守护**：用 systemd/launchd/supervisor 等监控 `mac_dashboard.py`，崩溃或设备重启后自动拉起。
- **桥与网络**：保证 Windows 桥接程序持续写 `shared_quote.json`；网络恢复后无需重启 dashboard，超 5 分钟未更新会自动暂停发单，更新后自动恢复。
- **执行端**：Windows 端应在执行完 `order_signal.json` 中的委托后，更新持仓并写回桥数据，以便 Mac 端通过「真实持仓同步」与实盘一致。

*以上逻辑均在 `mac_dashboard.py` 中实现，无需额外配置即可生效。*
